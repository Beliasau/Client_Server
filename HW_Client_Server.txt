HW
Client_Server

1) Прочиать про клиент-серверную архитектуру
2) Что такое HTTP и HTTPS
3) HTTP методы / Идемпотентные / Безопасные
4) HTTP статус коды сервера
5) Что такое ядро браузера 
6) Какие браузеры какие ядра используют
7) Что такое API
8) Что такое ендпоинты
9) URL (URI, URL, URN)
10) Логи (Logs)
11) DNS
12) Идентификация, Аутентификация, Авторизация
13) Что такое IP  / MAC-адрес 
14) Что такое октеты в DNS
15) Что такое порт, сколько портов у Linux сервера
16) OSI модель. Уровни OSI   /  TCP/IP модель  /   TCP|UDP|QUIC
17) Хедеры http запросов
18) Что происходит при открытии сайта в браузере?
19) internet
20) HTTP session
21) rest/soap
22) XML, JSON
23) DevTools
24) Domain / subdomain
25) token (refresh token ,Access token)
26) Cookie (LocalStorage, sessionStorage)
27) cache
28) PROXY
29) web server/Services/application
30) vpn
31) балансировщик сервер (load balancer)
32) как сделать так чтобы JS код на клиенте не смог прочитать cookie?
33) Что такое WADL?
34)  Что такое FTP?
35) OWASP
36) Что такое WebSocket и как проверить обрыв соединения?
37) ajax
38) Man-in-the-Middle






==================================================================================================================================









1)		Клиент-серверная архитектура

	Клиент (заказчик услуг) - программа или локальный компьютер, который отправляет на сервер запросы
 и получает от него ответы
	Сервер (поставщик услуг)- программа или локальный компьютер, который получает запрос от клиента
обрабатывает его и отправляет ответ обратно
	Клиент-серверная архитектура- архитектура в которой вычеслительная или сетевая нагрузка распределяется
 между клиентом и сервером
	Толстый клиент- клиент на котором происходит все вычеслительные процессы, сервер нужен только для 
сохранения основной информации(1С-бухгалтерия, онлайн игры)
	Тонкий клиент- все вычесления происходят на сервере (например - браузер)












2)		HTTP(80 порт) и HTTPS(443 порт)
	HTTP (hyper text transfer protocol)- протокол прикладного уровня для передачи данных (текстовой информации
или других данных зашифрованых в текстовом формате)

	HTTPS (HTTP Secure)- протокол для передачи конфиденциальной информации путем ее шифрования.
	HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы SSL и TLS. Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения — от снифферских атак и атак типа man-in-the-middle, при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют
Структура HTTP/S запроса:
1)HTTP метод/ путь/ версия HTTP протокола
2)заголовок(HEADERS)
3)тело запроса
GET /tutorials/other/top-20-mysql-best-practices/ HTTP/1.1

Структура HTTP/S ответа
1)версия HTTP протокола   статус код    статус message
2)HEADERS HTTP/s
3)тело ответа












3)		HTTP методы
Методы показывают какое желаемое действие выполнится для данног ресурса
	Методы бывают: безопасные, кэшируемые, идемпотентные

Безопасные- не меняют состояния сервера проводят операции, только чтение(все безопасные методы идемпотентны)
	GET. Head. Opnions

Кэшируемые методы -  это (Кешируемые ответы), HTTP-ответы, которые могут быть закешированы, то есть сохранены для дальнейшего восстановления и использования позже, тем самым снижая число запросов к серверу. Не все HTTP-ответы могут быть закешированы.

Идемпотентные- методы при которых один и от же запрос имеет один итот же ответ, не меняя состояния сервера
единичный и множественные вызовы этого метода, 
с идентичным набором данных, будут иметь тот же результат выполнения 
(без сторонних эффектов)

	Методы:
GET- извлекает данные
Head- работает как и Get, но без тела ответа
Post- для отправки информации на сервер
Put- заменяет все текущие данные ресурса, данными запроса
Delete- удаляет указанный ресурс (информацию)
Options
Trace
Patch- частичное изменение ресурса

CRUD — акроним, обозначающий четыре базовые функции, используемые 
при работе с базами данных: создание (англ. create), чтение (read), модификация (update), удаление (delete). 
(в этом случае это GET. POST. PUT. DELETE.)

GET
Метод GET запрашивает представление ресурса. Запросы с использованием этого 
метода могут только извлекать данные.

Запрос имеет тело		Нет
Успешный ответ имеет тело	Да
Безопасный			Да
Идемпотентный			Да
Кешируемый			Да
Допускается в HTML-формах	Да

Синтаксис
GET /index.html

HEAD
запрашивает ресурс так же, как и метод GET, но без тела ответа.
Такой запрос может быть выполнен перед загрузкой большого ресурса, 
например, для экономии пропускной способности.

Запрос имеет тело		Нет
Успешный ответ имеет тело	Нет
Безопасный			Да
Идемпотентный			Да
Кешируемый			Да
Допускается в HTML-формах	Нет

Синтаксис
HEAD /index.html

POST
используется для отправки сущностей к определённому ресурсу. 
Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.

Запрос имеет тело		Да
Успешный ответ имеет тело	Да
Безопасный			Нет
Идемпотентный			Нет
Кешируемый			Только если включена информация о свежести сообщения
Допускается в HTML-формах	Да

Синтаксис
POST /index.html

PUT
заменяет все текущие представления ресурса данными запроса.
PUT содержится новая версия ресурса целиком.
Разница между PUT и POST в том, что PUT является идемпотентным,  в случае с POST, 
множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.

Запрос имеет тело		Да
Успешный ответ имеет тело	Нет
Безопасный			Нет
Идемпотентный			Да
Кешируемый			Нет
Допускается в HTML-формах	Нет

Синтаксис
PUT /new.html HTTP/1.1

DELETE
удаляет указанный ресурс.

Запрос имеет тело		Может
Успешный ответ имеет тело	Может
Безопасный			Нет
Идемпотентный			Да
Кешируемый			Нет
Допускается в HTML-формах	Нет

Синтаксис
DELETE /file.html HTTP/1.1

CONNECT
устанавливает "туннель" к серверу, определённому по ресурсу.
метод CONNECT может использоваться для доступа к сайту, который использует 
SSL (en-US) (HTTPS). Клиент запрашивает HTTP-прокси-сервер для туннелирования 
TCP-соединения с желаемым назначением. За тем сервер переходит к подключению 
от имени клиента. После того, как соединение установлено сервером, прокси-сервер 
продолжает проксировать поток TCP к клиенту и от него.

Синтаксис
CONNECT www.example.com:443 HTTP/1.1

OPTIONS
используется для описания параметров соединения с ресурсом.
Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) 
чтобы указать весь сервер целиком.

Запрос имеет тело		Нет
Успешный ответ имеет тело	Да
Безопасный			Да
Идемпотентный			Да
Кешируемый			Нет
Допускается в HTML-формах	Нет

Синтаксис
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1

TRACE
выполняет вызов возвращаемого тестового сообщения с ресурса.
выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя полезный механизм отладки.
Конечный получатель запроса должен отразить полученное сообщение, исключая 
некоторые поля описанные ниже, назад клиенту как тело сообщения с ответом 200 (OK) 
с заголовком Content-Type message/http. Конечный получатель это либо исходный сервер, 
либо первый сервер получивший значение Max-Forwards в запросе.

Синтаксис
TRACE /index.html

PATCH
используется для частичного изменения ресурса.
PATCH используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.

Иными словами, в PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс, находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии. А в PUT содержится новая версия ресурса целиком.














4)		HTTP статус коды сервера
Статус код- часть первой строке ответа от сервера при запросах по HTTP протоколу
1**		Информационные ()
100-199
2**		Успешные(Succes)
200-299
3**		Перенаправления(Redirection)
300-399
4**		Ошибка на стороне клиента(client error)
400-499
5**		Ошибка на стороне сервера(Server error)
500-599











5)		ядро браузера 
Браузер=оболочка + ядро
Оболочка- пользовательский интерфейс для настройки работы
Ядро(движок)- программа или модуль, отображает контент на основе языка разметки и выводит его на экран 











6) 		Какие браузеры какие ядра используют

	ядро Blink (от Google)
1 Chromium
2 Brave
3 Chrome
4 Comodo Dragon
5 Microsoft Edge
6 Epic Browser
7 Opera
8 SRWare Iron
9 Яндекс.Браузер
10 Амиго

	на движке Gecko (Mozilla)
1)Flock
2)K-Meleon
3)SeaMonkey
4)Camino
5)Mozilla Firefox
6)Waterfox

	Webkit (от Apple)
Apple Safari













7)		API
API(application programm interface) програмный интерфейс приложений
контракт по которому общаются между собой различные ПО, и определяет каким образом они будут общаться 
используя запросы и ответы 
API
API — сокращение от Application Programming Interface (программный интерфейс приложения). API — набор правил, протоколов и инструментов для взаимодействия между приложениями. Говоря простым языком, API — интерфейс, который определяет, как одна программа должна взаимодействовать с другой программой. Как правило, представляет собой набор функций, которые могут быть вызваны другой программой.















8)		ендпоинты
Endpoint- точка приема запроса на стороне сервера(API)
Route(маршрут)- URL к которому можно обратится разными HTTP методами. Маршрут может иметь несколько эндпоинтов

















9)		URL (URI, URL, URN) универсальный указатель
URL(Uniform Resurs Locator)- указывает на место расположения в сети интернет
URN(Uniform Resurs Name)- указывает имя файла или ресурса в сети
URI(Uniform Resurs Identfier)- указывает и имя файла и его адрес
URI=URL+URN
Структуру URL
протокол(HTTP или HTTPS)://(хост или IP адрес):(номер порта)/(путь)?(параметр запроса)#(якорь)
протокол и хост обязательны 





















10) Логи 
(log-файлы, журналы) — это текстовые файлы, куда автоматически записываются все события, которые происходили в компьютерной системе. Их основная цель — помочь определить, почему на сайте или в программе возникает ошибка, а также найти того, кто совершил какое-то действие.

Разные программы на сервере как правило генерируют собственные лог-файлы. Вот наиболее основные из них:

главный системный лог — общая информация о системе, начиная с момента её запуска (данные о действиях с ядром Linux, обнаруженных устройствах, сетевых интерфейсах, работе различных служб вроде FTP-сервера или DNS-сервера, и ещё много о чём другом).

лог загрузки системы — сообщения от ядра. Сюда записываются данные об устройствах, которые загружаются вместе с системой. С помощью этого лога можно выполнить отладку системы, если она не загружается.

журнал авторизации пользователей — информация об авторизации пользователей. Здесь вы найдёте записи об успешных и неуспешных попытках входа в систему, логины пользователей, используемые механизмы аутентификации.

логи веб-сервера — журнал запросов к веб-серверу, информация об ошибках. Эта информация поможет найти битые ссылки и причины ошибок на сайте, а также покажет, кто слишком сильно нагружает сервер или пытается его взломать.

лог почтового сервера — записи обо всех отправленных и доставленных сообщениях, ошибки почтового сервера, причины отклонения писем.

логи базы данных — запросы к базам данных, ошибки сервера.

логи планировщика Cron — протокол выполненных задач, сообщения от самих команд, ошибки при запуске крона.
Это далеко не все логи, а только те, которые по нашему опыту используют чаще всего. В зависимости от того, какое программное обеспечение установлено у вас на сервере, у вас могут быть и другие лог-файлы.




















11)			DNS (Domain Name System «система доменных имён»)

компьютерная распределённая система для получения информации о доменах
Чаще всего используется для получения IP-адреса по имени хоста/ 
преобразует доменные имена, удобные для человеческого восприятия 
(например, www.amazon.com), в IP-адреса, понимаемые машиной (например, 192.0.2.44).

DNS-сервер — специализированное ПО для обслуживания DNS, 
а также компьютер, на котором это ПО выполняется. 

DNS-клиент — специализированная библиотека (или программа) для работы с DNS. 
В ряде случаев DNS-сервер выступает в роли DNS-клиента.

DNS-запрос (DNS query) — запрос от клиента (или сервера) серверу
DNS-запрос может быть рекурсивным — требующим полного поиска, 
— и нерекурсивным (или итеративным) — не требующим полного поиска.


что отдельно взятый DNS-сервер не может хранить вообще всю информацию об адресах сайтов 
и связанных с ними IP-адресами. Есть исключения — корневые DNS-серверы. При обращении 
к сайту компьютера пользователя браузер первым делом проверяет локальный файл 
настроек DNS, файл hosts. Если там нет нужного адреса, запрос направляется дальше — 
на локальный DNS-сервер интернет-провайдера пользователя.

Локальный DNS-сервер в большинстве случаев взаимодействует с другими DNS-серверами из 
региона, в котором находится запрошенный сайт. После нескольких обращений к таким 
серверам локальный DNS-сервер получает искомое и отправляет эти данные в браузер — 
запрошенный сайт открывается. Полученные данные сохраняются на локальном сервере, 
что значительно ускоряет его работу. Поскольку, единожды «узнав» IP-адрес сайта, 
запрошенного пользователем, локальный DNS сохраняет эту информацию. Процесс сохранения 
полученных ранее данных  называется КЭШИРОВАНИЕМ

Если пользователь обратится к ранее запрошенному сайту еще раз, то сайт откроется быстрее, 
поскольку используется сохраненная информация. Правда, хранится кэш не вечно, время 
хранения зависит от настроек самого сервера.

IP-адрес сайта может измениться — например, при переезде на другой хостинг или сервер в 
рамках прежнего хостинга. В этом случае обращения пользователей к сайту, 
чей IP-адрес поменялся, некоторое время обрабатываются по-старому, то есть перенаправление 
идет на прежний «айпишник». И лишь через определенное время (например, сутки) кэш 
локальных серверов обновляется, после чего обращение к сайту идет уже по новому IP-адресу.


с определенным доменным именем может быть связано несколько ресурсов — сайт и почтовый сервер.
У этих ресурсов вполне могут быть разные IP-адреса, что дает возможность повысить 
надежность и эффективность работы сайта или почтовой системы. Есть у сайтов и поддомены, 
IP-адреса которых тоже могут быть разными.
Вся эта информация о связи сайта, поддоменов, почтовой системы хранится в специальном файле 
на DNS-сервере. Его содержимое называется DNS-зона. Файл содержит следующие типы записей:

А — адрес веб-ресурса, который привязан к конкретному имени домена.
MX — адрес почтового сервера.
CNAME — чаще всего этот тип записи используется для подключения поддомена.
NS — адрес DNS-сервера, который отвечает за содержимое других ресурсных записей.
TXT — любая текстовая информация о доменном имени.
SPF — данные с указанием списка серверов, которые входят в список доверенных для отправки 
	писем от имени указанного домена.
SOA — исходная запись зоны, в которой указаны сведения о сервере и которая содержит шаблонную 
	информацию о доменном имени.


После регистрации доменного имени нужно «рассказать» о нем DNS-серверам. 
Для этого нужно прописать ресурсные записи, что обычно делается в админке хостинг-провайдера 
или доменного провайдера. Примерно через сутки DNS-записи пропишутся в локальном сервере, 
также они попадут и в реестры всех прочих DNS-серверов. Как только это произойдет, 
новый домен станет нормально открываться браузером, доменное имя, активируется
















12)		 Идентификация, Аутентификация, Авторизация

Идентификация- процесс выявления или определения уникального идентификатора, обьекта или пользователя, и сравнением 
его с уже имеющемися в системе(два одинаковых идентификатора не должно существоать)
ПРИМЕР ввод логина в систему

Аутентификация- процесс проверки подленности идентифицированного пользователя или обекта
ПРИМЕР ввод пароля в систему 
ввод кода из СМС или почтового ящика (2х факторная аутентификация)

Авторизация- процесс предоставления пользователю или группе пользователей прав доступа к системе
или выполнению ими определенных действий(чтение или удаление файлов)
















13) 		Что такое IP / MAC-адрес 

IP-адрес (от англ. Internet Protocol) — уникальный числовой идентификатор устройства в компьютерной сети, работающей по протоколу IP.
В сети Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети. В версии протокола IPv4 IP-адрес имеет длину 4 байта, а в версии протокола IPv6 — 16 байт.
ІP-адрес — это, по сути, почтовый адрес устройства в сети. IP-адрес должен быть у каждого сайта, смартфона, компьютера, сервера, умной лампочки и прочее, иначе пакеты данных просто не будут знать, куда им лететь.
IPv4 адрес состоит из 4 блоков по 8 бит, каждый из которых называется октетом, и записывается в виде десятичных цифр, разделенных точкой.


MAC-адрес (от англ. Media Access Control — надзор за доступом к среде, также Hardware Address, также физический адрес) — уникальный идентификатор, присваиваемый каждой единице сетевого оборудования или некоторым их интерфейсам в компьютерных сетях Ethernet















14) 		Что такое октеты в DNS

IP-адрес (ipv4) состоит из четырех частей, записаных в виде десятичных чисел с точками,
каждую из этих четырех частей называют ОКТЕТОМ. Октет представляет собой 8 двоичных цифр
или 3 в десятичном виде

IPv6 адрес теперь состоит из 8 групп шестнадцатеричных чисел, разделенных двоеточиями.
2001:0db8:0000:0000:0000:0000:0010:ad12
IP-адреса в (ipv6) стали длиной 128 бит.(16 байт)

DNS(Domain Name Sistem) технология, которая позволяет получить IP сайта через запрос клиента с доменным именем.
клиент отправляет запрос с доменным именем ресурса на DNS сервер, DNS возвращает ответ уже с IP адресом ресурса,
после чего клиент уже обращается по этому адресу

	Структура пакета DNS

    +---------------------+
    |        Header       | Заголовок
    +---------------------+
    |       Question      | Секция запросов
    +---------------------+
    |        Answer       | Секция ответа
    +---------------------+
    |      Authority      | Секция ответа об уполномоченных серверах
    +---------------------+
    |      Additional     | Секция ответа дополнительных записей
    +---------------------+
Header — Заголовок DNS пакета, состоящий из 12 октет.
Question section — в этой секции DNS-клиент передает запросы DNS-серверу сообщая о том,
для какого имени необходимо разрешить (зарезолвить) запись DNS
Answer section — сервер сообщает клиенту ответ или несколько ответов на запрос, 
в котором сообщает вышеуказанные данные.
Authoritative Section — содержит сведения о том, с помощью каких авторитетных серверов 
было получена информация включенная в секцию DNS-ответа.
Additional Record Section — дополнительные записи, которые относятся к запросу, 
но не являются строго ответами на вопрос.
Записей в секциях может быть как несколько, так и не быть вообще. Всё определяется заголовком.


















15)		 Что такое порт, сколько портов у Linux сервера
Логический номер программы, которая обслуживает интернет соединение на прикрепленном адресе IP
Порт отображается в виде 16 битного числа от 1 до 65535
Порт сервера- это цифровой идентификатор (набор цыфр до 16 Бит) программы, которая используется для создания определенного интернет соединения привязанного к IP- адресу.

1порт -1 программма  
Системные порты   0-1023
пользовательские  1024-49151
динамические(частные)   49152-65535
HTTP- 80 port
HTTPS- 443 port

















16) 	OSI модель.	Уровни OSI /  TCP/IP модель

Модель OSI (Open System Interconnection), или эталонная модель взаимодействия открытых систем описывает, как устройства в локальных и глобальных сетях обмениваются данными и что происходит с этими данными.

описывает как информация проходя от уровня к уровню преобразуется из файла в набор битов и байтов, электросигнлов в проводах витой пары

При этом сама по себе эталонная модель — не стандарт интернета, как, например, TCP/IP; её можно сравнить с фреймворками в мире языков программирования

Сетевая модель OSI (The Open Systems Interconnection model) — сетевая модель стека (магазина) сетевых протоколов OSI/ISO. Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.


Прикладной (application)		HTTP,FTP,POP3,WebSocket,SMTP.TFTP
взаимосвязь приложений на компьютере с внешней сетью
данные

Представления (presentation)		ASCII,EBCDIC,JPEG,MIDI
преобразование форматов данных (сжатие и кодирование)
данные

Сеансовый (session)			RPC,PAP,gRPC,SMPP
обмен данными, синхронизация
организация сеансов связи между приложениями на компьютер
данные

транспортный (transport)		TCP,UDP,SCTP
доставка информации по каналам внешней связи между конечными пунктами
сегменты

сетевой (network)			IPv4,IPv6,IPsec,
пакеты
появляется пакет данных в который вставляется IP адрес от DNS сервера
роутер, маршрутизатор

канальный (data link)			EThernet,DSL,ARP
(LLC/MAC) проверка и исправление погрешности передачи
кадры
сетевой мост, коммутатор, точка доступа

физический (physical)			Ethernet,USB,WI-fi,bluetooth
радиосигналы, электрические и оптические сигналы
витая пара, кодирование 0 и 1, провода
биты

TCP(transmission control protocol) протокол передачи трафика который чувствителен к потри пакетов (email)
UDP(user datagram protocol) применяется когда потеря нескольких пакетов не критична (стриминговые сервисы)
QUIC protocol QUIC — новый транспортный протокол связи, который отличается уменьшенным временем задержки, большей надёжностью и безопасностью, чем широко используемый сегодня TCP
QUIC позволяет мультиплексировать несколько потоков данных между двумя компьютерами, работая поверх протокола UDP, и содержит возможности шифрования, эквивалентные TLS и SSL


TCP/IP модель

TCP/IP сетевая модель передачи данных имеет 4 уровня
основными протоколами являются TCP и IP

Стек протоколов TCP/IP (Transmission Control Protocol/Internet Protocol, протокол управления передачей/протокол интернета) — сетевая модель, описывающая процесс передачи цифровых данных. Она названа по двум главным протоколам, по этой модели построена глобальная сеть интернет

1 КАНАЛЬНЫЙ(уровень доступв к сети)
описывает, каким образом передаются пакеты данных через физический уровень, и определит, 
как информация будет передаваться от одного устройства к другому. 
Информация здесь кодируется, делится на пакеты и отправляется по нужному каналу
Канальный уровень иногда разделяют на 2 подуровня — LLC и MAC

2 СЕТЕВОЙ 
отвечает за объединение локальных сетей в глобальную. И сетевой уровень также отвечает 
за адресацию хостов, упаковку и функции маршрутизации
Основные протоколы (IP, ARP, ICMP, IGMP)

3 ТРАНСПОРТНЫЙ
известный как транспортный уровень хост-хос
Основные протоколы TCP и UDP
отвечает за предоставление прикладного уровня сервисами связи сеанса и датаграмм

4 ПРИКЛАДНОЙ
На прикладном уровне (Application layer) работает большинство сетевых приложений



			Обработка данных во время передачи

В многоуровневой системе, устройства уровня обмениваются данными в другом формате, 
который известен как protocol data unit (PDU)(бит, кадр, пакет, данные)

когда пользователь запрашивает просмотр веб-сайта на компьютере, программное обеспечение 
удаленного сервера сначала передает запрошенные данные на прикладной уровень, где они 
обрабатываются от уровня к уровню, при этом каждый уровень выполняет свои назначенные функции. 
Затем данные передаются по физическому уровню сети до тех пор, пока их не получит 
конечный сервер или другое устройство. На этом этапе данные снова передаются вверх по уровням, 
каждый уровень выполняет назначенные ему операции, пока данные не будут использованы 
принимающим программным обеспечением.
Во время передачи каждый слой добавляет верхний или нижний колонтитул или оба к PDU, 
поступающему с верхнего уровня, который направляет и идентифицирует пакет. 
Этот процесс называется инкапсуляцией. Верхний (и Нижний колонтитулы) и данные 
вместе образуют PDU для следующего уровня. Процесс продолжается до достижения 
самого низкого уровня (физического уровня или уровня доступа к сети), с которого 
данные передаются на принимающее устройство. В приемном устройстве происходит 
обратный процесс, де-инкапсуляции данных на каждом уровне. верхние и нижние 
колонтитулы направляют операции. Затем приложение, наконец, использует данные. 
Процесс продолжается до тех пор, пока все данные не будут переданы и получены.


				РАЗЛИЧИЯ

Стек протоколов TCP/IP — набор сетевых протоколов, на которых базируется интернет. 
Обычно в стеке TCP/IP верхние 3 уровня (прикладной, представительный и сеансовый) 
модели OSI объединяют в один — прикладной. Поскольку в таком стеке не предусматривается 
унифицированный протокол передачи данных, функции по определению типа данных 
передаются приложению.

В отличие от эталонной модели OSI, модель ТСР/IP в большей степени ориентируется 
на обеспечение сетевых взаимодействий, нежели на жесткое разделение функциональных уровней. 
Для этой цели она признает важность иерархической структуры функций, 
но предоставляет проектировщикам протоколов достаточную гибкость в реализации. 
Соответственно, эталонная модель OSI гораздо лучше подходит для объяснения 
механики межкомпьютерных взаимодействий, но протокол TCP/IP стал основным межсетевым протоколом.


















17)		 Хедеры (заголовки) http запросов
в HEADERS содержится служебная информация(информация о хосте, пользователе, инф. для авторизации и тд),
 и не видна для пользователя 
HEADERS содержит информацию в формате (ключ: значение)
ПРИМЕР:

Transfer-Encoding: chunked
Date: Sat, 28 Nov 2009 04:36:25 GMT
Server: LiteSpeed
Connection: close
X-Powered-By: W3 Total Cache/0.8
Pragma: public
Expires: Sat, 28 Nov 2009 05:36:25 GMT
Etag: "pub1259380237;gz"
Cache-Control: max-age=3600, public
Content-Type: text/html; charset=UTF-8
Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT
X-Pingback: https://net.tutsplus.com/xmlrpc.php
Content-Encoding: gzip
Vary: Accept-Encoding, Cookie, User-Agent

после HEADERS идет тело HTTP/S протокола и они разделены пустой строкой













18) Что происходит при открытии сайта в браузере?


DNS (поиск ip адреса ресурса в кэше браузера, кешэ провайдера)

проверка кэш в браузере
проверяет есть ли нужные элементы страницы локально в кэше 

запрос на сервер 

ответ с сервера

кэширование
данных полученных с сервера

парсинг html
и
запросы на получение Json, Xml картинок и тд

отрисовка сайта












19) internet
коммуникационная сеть и всемирная система объединённых компьютерных сетей для хранения и передачи информации












20) HTTP session
Обычно под сессией понимается «последовательность запросов, сделанных конечным клиентом (веб-браузером, приложением, краулером и др.) во время посещения определённого хоста»















21) rest/soap

SOAP


(Simple Object Access Protocol — простой протокол доступа к объектам)
протокол обмена структурированными сообщениями в распределённой вычислительной среде(наоснове XML).
	(SOAP — это формат обмена сообщениями.) 
	используется для обмена произвольными сообщениями в формате XML
	В SOAP вы используете формат SOAP XML для запросов и ответов.
	SOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS
	Чаще всего SOAP используется поверх HTTP.
	SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и 
	доступа к ним, основанный на языке XML.
	
Использование SOAP для передачи сообщений увеличивает их объём и снижает скорость обработки

СТРУКТУРA ПРОТОКОЛА
	Envelope — корневой элемент, который определяет сообщение 
	и пространство имен, использованное в документе.

	Header — содержит атрибуты сообщения, например: информация 
	о безопасности или о сетевой маршрутизации

	Body — содержит сообщение, которым обмениваются приложения.

	Fault — необязательный элемент, который предоставляет 
	информацию об ошибках, которые произошли при обработке сообщений.

ПРИМЕР

SOAP-запрос

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetails xmlns="http://warehouse.example.com/ws">
       <productID>12345</productID>
     </getProductDetails>
   </soap:Body>
</soap:Envelope>

ОТВЕТ

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetailsResponse xmlns="http://warehouse.example.com/ws">
       <getProductDetailsResult>
         <productID>12345</productID>
         <productName>Стакан граненый</productName>
         <description>Стакан граненый. 250 мл.</description>
         <price>9.95</price>
         <currency>
             <code>840</code>
             <alpha3>USD</alpha3>
             <sign>$</sign>
             <name>US dollar</name>
             <accuracy>2</accuracy>
         </currency>
         <inStock>true</inStock>
       </getProductDetailsResult>
     </getProductDetailsResponse>
   </soap:Body>
</soap:Envelope>


REST 

(Representational State Transfer — «передача репрезентативного состояния» или передача состояния представления)
Архитектурный стиль ПО для распределенных систем, который, как првило, используется для построения веб-служб
АРХИТЕКТУРНЫЙ СТИЛЬ, КОТОРЫЙ ОПРЕДЕЛЯЕТ КАКИМИ СРЕДСТВАМИ БУДУТ ОБЩАТЬСЯ МЕЖДУ СОБОЙ СЕРВЕР И КЛИЕНТ

REST — это набор правил того, как программисту организовать написание кода серверного приложения, 
чтобы все системы легко обменивались данными и приложение можно было масштабировать.

REST API \ RESTful
это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют RESTful.
REST - набор архитектурных принципов построения сервис-ориентированных систем.
RESTful - прилагательное, употребляющееся по отношению к сервисам, которые следуют принципам REST.

	REST поддерживает различный форматы XML. текстовые форматы
	работает только по протоколам HTTP и HTTPS
	в REST используется JSON
	может быть помещен в cash
	архитектурный стиль(нет огромного количества правил)
	быстрее SOAP
	занимает меньше места
	записывает информацию в более удобном (читаемом) виде


REST и SOAP сравнение

REST и SOAP на самом деле не сопоставимы. REST — это архитектурный стиль. SOAP — это формат обмена сообщениями. Давайте сравним популярные реализации стилей REST и SOAP.

Пример реализации RESTful: JSON через HTTP
Пример реализации SOAP: XML поверх SOAP через HTTP

На верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST — это архитектурный подход, ориентированный на использование HTTP в качестве транспортного протокола.

Специфика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML
Специфика REST — использование HTTP в качестве транспортного протокола. Он подразумевает наилучшее использование функций, предоставляемых HTTP — методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.

Формат обмена сообщениями
В SOAP вы используете формат SOAP XML для запросов и ответов.
В REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.

Определения услуг

SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.
REST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.

Транспорт

SOAP не накладывает никаких ограничений на тип транспортного протокола. Вы можете использовать либо Web протокол HTTP, либо MQ.

REST подразумевает наилучшее использование транспортного протокола HTTP

Простота реализации

RESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.

REST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.
Однако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.












22) XML,    JSON


JSON (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript.
Несмотря на происхождение от JavaScript (точнее, от подмножества языка стандарта ECMA-262 1999 года), формат считается независимым от языка и может использоваться практически с любым языком программирования. Для многих языков существует готовый код для создания и обработки данных в формате JSON.

JSON обьект

JSON обьект - НЕупорядоченное множество пар - "ключ": "значение"

{
"ключ": "значение",
"ключ": "значение",
"ключ": "значение",
"ключ": "значение"
} 

название_обьекта["ключ"]          достать из обьекта значение ключа
название_обьекта.ключ


Json массив

Json массив- это упорядоченное множество значений

[1, 'hello', 3]

название_массива[индекс элемента]       достать из массива значение 
название_массива[1]

массив начинается с [0] индекса элемента


XML 
(eXtensible Markup Language) — «расширяемый язык разметки»
XML — используется в SOAP (всегда) и REST-запросах (реже)
используется для хранения и передачи информации

вверху XML документа можно увидеть
<?xml version="1.0" encoding="UTF-8"?>
Эта строка называется XML прологом. Она показывает версию XML, который используется 
в документе, а также кодировку. Пролог необязателен, если его нет — это ок. 
Но если он есть, то это должна быть первая строка XML документа.
UTF-8 — кодировка XML документов по умолчанию.


В XML каждый элемент должен быть заключен в теги. 
Тег — это некий текст, обернутый в угловые скобки:
<tag>
Текст внутри угловых скобок — название тега.
Тега всегда два:
Открывающий — текст внутри угловых скобок
<tag>
Закрывающий — тот же текст (это важно!), но добавляется символ «/»
</tag>

В  XML-документе есть корневой элемент. Это тег, 
с которого документ начинается, и которым заканчивается. 

У элемента могут быть атрибуты — один или несколько. Их мы указываем внутри 
отрывающегося тега после названия тега через пробел в виде
название_атрибута = «значение атрибута»
Например:
<query attr1=“value 1”>Виктор Иван</query>
<query attr1=“value 1” attr2=“value 2”>Виктор Иван</query>














23) DevTools

Инструменты разработчика (от англ. «development tools» или сокращённо «DevTools») ─ это программы, позволяющие создавать, тестировать и отлаживать (debug) программное обеспечение.

Современные браузеры, Safari, Firefox, Microsoft Edge, Chrome, Яндекс и другие, имеют встроенные инструменты разработчика, позволяющие просмотреть исходный код сайта. Отдельно устанавливать их не требуется. С их помощью можно просматривать и отлаживать HTML сайта, его CSS и Javascript. Также можно проверить сетевой трафик, потребляемый сайтом, его быстродействие и много других параметров.


























24) Domain / subdomain

Понятия «домен» и «сайт» часто путают, но это не одно и то же. Сайт — это одна или несколько связанных между собой веб-страниц. А домен — это уникальный адрес сайта. Например, mchost.ru — это наш домен, а наш сайт — это все страницы и контент, который вы просматриваете

Корневой домен - root domain. Домен самого верхнего уровня, отмечается "точкой" (нулевой уровень). В общепринятом использовании "точка" не отображена в составе доменного имени.

Домены верхнего (первого уровня).
Доменные имена верхнего уровня еще называют доменными зонами.
К доменам первого (верхнего) уровня относят доменные имена типа .ru, .рф, .su, .com, .net, .club.

Домены верхнего уровня разделяют на несколько групп:

Национальные домены верхнего уровня (cctld). На территории Российской Федерации к таким доменам относят доменные зоны .RU, .РФ, .SU. Так же к национальным доменам можно отнести доменные зоны: .ua (Украина), .de (Германия), .eu (Европейский Союз).
Международные (общие) домены верхнего уровня (generic Top Level Domain (gTLD)). Это такие доменные зоны как: .com, .info, .biz, .name, .org.

Домены второго уровня.

На доменах первого уровня регистрируются домены второго уровня. Именно домены второго уровня распространены для коммерческого использования. К примеру, доменами второго уровня является сайты hoster.ru, domenus.ru, google.com.
поддомен (или субдомен) — это домен, который является частью домена более высокого уровня. Как это выглядит: если site.com — основной домен, то poddomen.site.com — это поддомен. Во многих случаях при размещении сайта папка поддомена лежит в папке самого домена.

Домены третьего уровня.

На доменах второго уровня могут создаваться домены третьего уровня. К доменам третьего уровня можно отнести такие домены как filanco.com.ua, datahouse.com.ru.  

Международные домены gTLD

.biz — сайты для бизнеса
.com — сайты коммерческих организаций
.edu — образовательные ресурсы
.gov — сайты правительственных учреждений
.info — информационные сайты
.mil — сайты военных организаций
.movie — официальные сайты фильмов
.museum — сайты музеев
итд.














25) token (refresh token ,Access token и тд)

JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения подлинности аккаунта.

токен - это цифровой ключ для доступпа к данным на сервере

Access- и refresh-токены
Access-токен — это токен, который предоставляет доступ его владельцу к защищённым ресурсам сервера. Обычно он имеет короткий срок жизни и может нести в себе дополнительную информацию, такую как IP-адрес стороны, запрашивающей данный токен.

Refresh-токен — это токен, позволяющий клиентам запрашивать новые access-токены по истечении их времени жизни. Данные токены обычно выдаются на длительный срок.

Схема работы
Как правило, реализована следующая схема:

Клиент проходит аутентификацию в приложении (к примеру, с использованием логина и пароля).
В случае успешной аутентификации сервер отправляет клиенту access- и refresh-токены.
При дальнейшем обращении к серверу клиент использует access-токен. Сервер проверяет токен на валидность и предоставляет клиенту доступ к ресурсам.
В случае, если access-токен становится невалидным, клиент отправляет refresh-токен, в ответ на который сервер предоставляет два обновлённых токена.
В случае, если refresh-токен становится невалидным, клиент опять должен пройти процесс аутентификации 

Сервер может не заниматься созданием токенов, а предоставить это внешним сервисам

XSS
JSON-токены могут храниться в браузере двумя способами: в DOM-хранилище или в куки. В первом случае система может быть подвержена XSS-атаке, так как JavaScript имеет доступ к DOM-хранилищу и злоумышленник может извлечь оттуда токен для дальнейшего использования от имени пользователя. При использовании куки можно выставить HttpOnly-флаг(заголовок в хедере), который предотвращает доступ JavaScript к хранилищу. Таким образом, злоумышленник не сможет извлечь токен и приложение становится защищенным от XSS

токен может присылаться на клиент:
1) в хедере респонса с заголовком (Set-Cookie) (Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly)
2) в хедере респонса с заголовком (cookie)
3) в body респонса (в json )

















26) Cookie (LocalStorage, sessionStorage)

Ку́ки  — небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователях.

используется для:
аутентификации пользователя;
хранения персональных предпочтений и настроек пользователя;
отслеживания состояния сеанса доступа пользователя;
хранения сведений статистики о пользователях.

В техническом плане cookie представляют собой фрагменты данных, изначально отправляемых веб-сервером браузеру. При каждом последующем посещении сайта браузер пересылает их обратно серверу. Без cookie каждый просмотр веб-страницы является изолированным действием, не связанным с просмотром других страниц того же сайта, с помощью же cookie можно выявить связь между просмотром разных страниц. Кроме отправки cookie веб-сервером, cookie могут создаваться скриптами на языках вроде JavaScript, если они поддерживаются и включены в браузере.

Cookie могут устанавливать дату их удаления, в этом случае они будут автоматически удалены браузером в указанный срок. Если дата удаления не указана, cookie удаляются сразу, как только пользователь закроет браузер. 

Сессионные cookie, также известные как временные cookie, существуют только во временной памяти, пока пользователь находится на странице веб-сайта. Браузеры обычно удаляют сессионные cookie после того, как пользователь закрывает окно браузера

постоянные cookie-файлы удаляются в определённую дату или через определённый промежуток времени. Это означает, что информация о cookie будет передаваться на сервер каждый раз, когда пользователь посещает веб-сайт, которому эти cookie принадлежат. По этой причине постоянные cookie иногда называются следящие cookie, поскольку они могут использоваться рекламодателями для записи о предпочтениях пользователя в течение длительного периода времени

Зомби-cookie  (или evercookie, или persistent cookie)- неудаляемые или трудно удаляемые cookie, 
которые можно восстановить в браузере с помощью JavaScript.
Зомби-cookie хранятся браузером в разных хранилищах, и при удалении только из одного хранилища 
система может восстановить этот файл из других хранилищ

Супер-cookie — это cookie-файл с источником домена верхнего уровня (например, .ru) 
или общедоступным суффиксом (например, .co.uk). Обычные cookie, напротив, имеют 
происхождение от конкретного доменного имени, например example.com.
Термин (супер-cookie) иногда используется для отслеживания технологий, которые не используют файлы cookie HTTP


LocalStorage, sessionStorage

Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.

Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage)
Но ведь у нас уже есть куки. Зачем тогда эти объекты?
В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому мы можем хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.
Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.
Основные особенности localStorage:
Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.

Локальное хранилище - это объект localStorage, который позволяет хранить данные для каждого домена в течение неограниченного времени (после закрытия вкладки браузера, самого браузера, перезагрузки компьютера), а точнее пока пользователь самостоятельно не удалит данные
LocalStorage нужен только для одного — хранить определенные данные между сессиями пользователя.Например, браузерные игры, которые используют его как сохраненку, или записать момент, на котором пользователь остановился при просмотре видео, различные данные для форм и т.д.

Объект sessionStorage используется гораздо реже, чем localStorage.
Свойства и методы такие же, но есть существенные ограничения:
sessionStorage существует только в рамках текущей вкладки браузера.
Другая вкладка с той же страницей будет иметь другое хранилище.
Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.

====================

Set-Cookie HTTP заголовок  используется 
для отправки cookies с сервера на агент 
пользователя(сохраняет куки локально).

HttpOnly Необязательный параметр (заголовка Set-Cookie)
Запрещает JavaScript доступ к cookie
Полезно для защиты от XSS-атак.

Как и любой другой HTTP-заголовок, cookie должны передаваться в браузер до того, как будут переданы какие-либо другие данные

Запрашивая страницу, браузер отправляет веб-серверу короткий текст с HTTP-запросом
GET /index.html HTTP/1.1
Host: www.example.org
5

Сервер отвечает, отправляя запрашиваемую страницу вместе с текстом, содержащим HTTP-ответ. Там может содержаться указание браузеру сохранить cookie:

HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value

Строка Set-cookie отправляется лишь тогда, когда сервер желает, чтобы браузер сохранил cookie. В этом случае, если cookie поддерживаются браузером и их приём включён, браузер запоминает строку name=value (имя = значение) и отправляет её обратно серверу с каждым последующим запросом.

GET /spec.html HTTP/1.1
Host: www.example.org
Cookie: name=value
Accept: */*

cookie может быть изменено сервером путём отправления новых строк Set-Cookie: name=new_value. После этого браузер заменяет старое cookie с тем же name на новую строку.

Cookie также могут устанавливаться программами на языках типа JavaScript, встроенными в текст страниц, или аналогичными скриптами, работающими в браузере.













27) cache                          (Application Cache API ???)


CACHE  промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью.

Кэш (cache) – это совокупность временных копий файлов программ, а также специально отведенное 
место их хранения для оперативного доступа. Соответственно, кэшированием называется 
процесс записи этих данных при работе операционной системы и отдельных программ.
временные файлы создаются для последующего их получения с большей скоростью

Аппаратный.  временные файлы записываются на само устройство в специально 
отведенные для этого участки памяти. Например, аппаратное кэширование в центральном процессоре 
выполняется в трех видах cache-памяти – L1, L2 и L3. Это позволяет программам быстро извлечь 
их при необходимости без обращения к иным устройствам в системе.

Программный. Кэширование этого типа осуществляется в выделенный участок памяти в 
операционной системе (как правило, он имеет вид обычной папки). Расположение кэша у 
различных программ может быть разным. Например, браузеры сохраняют свои временные файлы 
в свои папки в разделе Document and Settings.

Заголовок Alt-Svc позволяет серверу определить альтернативный способ обращения к сайту и проинструктировать браузер о необходимости перенаправить запрос на новый хост, например, для балансировки нагрузки. В том числе возможно указание сетевого порта для проброса, например, указание 'Alt-Svc: http/1.1="other.example.com:443";ma=200' предписывает клиенту для получения запрошенной страницы соединиться с хостом other.example.org, используя сетевой порт 443 и протокол HTTP/1.1. Параметр "ma" задаёт максимальное время действия перенаправления.

Заголовок Alt-Svc также может применяться:
При организации DDoS-атак. Например, для TLS перенаправление может обеспечить уровень усиления в 60 раз так как начальный запрос клиента занимает 500 байт, ответ с сертификатом около 30 Кб. Генерируя подобные запросы в цикле на множестве клиентских систем можно добиться исчерпания доступных серверу сетевых ресурсов;

серверное кэширование (кэш на бэке)

виды серверого кэширования:
cache бд.
cache service (Redis)(информация хран на отдельноа cache сервере)
in-memory cache(информация хран в опер памяти самого сервера)
cache на Proxy сервере

принцип работы

1. сервер получает запрос от клиента
2. проверят есть ли нужные данные для ответа в кэше сервера (in-memory cache) 
3. если на сервере нет нужных данных - отправляется запрос в cache service (cache server Redis )
4. если на Redis есть нужная инфа, то она отправляется в ответе клиенту
5. если инфы в Redis нет, отправляется запрос в бд
6. в бд обрабатывается запрос и отправляется на сервер
7. сервер сохраняет ответ от бд в кэш и отправляет ответ клиенту


===============


браузерное кэширование (кэш на клиенте) 

кто решает как долго хранить кэш на клиенте? (сервер)

принцип работы браузерного кэширования.

1.При первой загрузке сайта в браузер идет получение всех его компонентов.
2.Анализируя данные, браузер делит их на статические (редко изменяемые изображения, коды страниц, CSS и др) и динамические. 
3.Статистические данные складируются в подпапки кэша на диске, для каждого сайта используется свой набор папок.
4.При повторном заходе браузер отображает статические компоненты из кэша (отправляется хедер с данными о куки в повторном запросе (If-None-Match, If-Modified-Since, итд) на сервер,  сервер определяет по хедеру обновился ли этот файл с момента последнего запроса,  и если файл не изменен присылает на клиент 304 статус код, который говорит использовать файл хранящийся в кэше клиента, если файл был обновлен на сервере, то с респонсом приходит 200 статус код с обновленным файлом )

подходы к кэшированию файлов:

1)сервер присылает респонс с хедерами Cache-Control, Expires они устоанавливают время хранения кэша
2)Etag (присылает хэш в респонсе с сервера, этот хэш отправляется в последующем запросе на сервер но уже в хедере If-None-Match, сервер определяет по хэшу обновился ли этот файл с момента последнего запроса,  и если файл не изменен присылает на клиент 304 статус код, который говорит использовать файл хранящийся в кэше клиента, если файл был обновлен на сервере, то с респонсом приходит 200 статус код с обновленным файлом)
3) Last-Modified.    If-Modified-Since 
работаю так же как и хедеры выше(Etag, и If-None-Match), только вместо хэша с сервера в хедере приходит дата последней модификации или изменения файла на сервере
4) версионирование файлов
принцип тот же, только каждому файлу присваивается версия (1.1,  1.2 итд)

Expires  используется для выставления временной точки, до которой страницу можно держать в кэше. 
Expires: Sun, 19 Aug 2023 03:00:00 GMT
Это значит, что страница не будет изменяться до трех часов ночи (по Гринвичскому времени) 19 августа 2023 года. Пока это время не пришло, браузер будет брать ее из кэша.

Cache-control — показывает время, в течение которого страница гарантированно не будет изменяться на сервере
Cache-Control: max-age=600
Означает, что страница с момента скачивания не будет изменяться в течение 600 секунд (10 минут). Пока это время не вышло, страница будет грузиться из кэша, но затем ее следует обновить с веб-сервера. 

Last Modified показывает время, в которое страница последний раз изменялась на сервере. Если же она не меняется, то ресурс отвечает заголовком Not Modified, и браузер грузит страницу из локального кэша. В ином случае нужно снова выгружать страницу полностью из сети.



















28) PROXY

▍Шлюзы

Шлюз (gateway) — это прокси-сервер, который перенаправляет входящие запросы или исходящие ответы, не модифицируя их. Такие прокси-серверы ещё называют туннелирующими прокси (tunneling proxy), веб-прокси (web proxy), прокси (proxy), или прокси уровня приложения (application level proxy). Эти прокси-серверы обычно совместно используются, например, всеми клиентами, находящимися за одним и тем же файрволом, что делает их хорошо подходящими для кэширования запросов.

▍Прямые прокси-серверы

Прямой прокси-сервер (forward proxy, часто такие серверы называют просто proxy server) обычно устанавливается на стороне клиента. Веб-браузер, который настроен на использование прямого прокси-сервера, будет отправлять исходящие запросы этому серверу. Затем эти запросы будут перенаправлены на целевой сервер, расположенный в интернете. Одно из преимуществ прямых прокси заключаются в том, что они защищают данные клиента (однако, если говорить об обеспечении анонимности в интернете, безопаснее будет пользоваться VPN).

▍Веб-ускорители

Веб-ускоритель (web accelerator) — это прокси-сервер, который уменьшает время доступа к сайту. Он делает это, заранее запрашивая у сервера документы, которые, вероятнее всего, понадобятся клиентам в ближайшем будущем. Подобные серверы, кроме того, могут сжимать документы, ускорять выполнение операций шифрования, уменьшать качество и размер изображений, и так далее.

▍Обратные прокси-серверы

Обратный прокси-сервер (reverse proxy) — это обычно сервер, расположенный там же, где и веб-сервер, с которым он взаимодействует. Обратные прокси-серверы предназначены для предотвращения прямого доступа к серверам, расположенным в частных сетях. Обратные прокси используются для балансировки нагрузки между несколькими внутренними серверами, предоставляют возможности SSL-аутентификации или кэширования запросов. Такие прокси выполняют кэширование на стороне сервера, они помогают основным серверам в обработке большого количества запросов.











29) web server/Services/application               отличия

Как работает веб-сервер

Веб-сервер – это технология, на которой размещаются код и данные веб-сайта. Когда вы вводите URL-адрес в браузере, этот URL-адрес фактически является идентификатором адреса веб-сервера.
взаимодействие клиента и Веб-сервера:
1.Браузер отправляет HTTP-запрос Веб-серверу на получение информации
2.Веб-сервер связывается с сервером баз данных для поиска соответствующих данных
3.Веб-сервер возвращает браузеру статический контент, такой как HTML-страницы, изображения, видео или файлы, в HTTP-ответе
4.Затем браузер отображает вам информацию



веб-сервис (Веб-служба)

веб-сервис = API, прикладной програмный интерфейс (api), который работает на сервере и предоставляет клиенту данные по HTTP/S через стандартизированную систему обмена сообщениями, веб-сервися делятся на SOAP и REST,


веб-сервис или API. есть ли разница ???
1) олдскульные (SOAP/XML) веб-сервисы называли так, потому что есть группа стандартов от W3С, и там используется именно понятие "web service" (https://www.w3.org/TR/ws-arch/#id2260892);
2) поэтому REST API называются так, чтобы побольше отличаться от веб-сервисов, и заодно подчеркнуть, что в таком взаимодействии единственный стандарт "для всех" - это HTTP. Все остальное - форматы запросов/ответов, степень соответствия архитектуре REST - определяется конкретным сервисом, и поэтому хотелось некий "легковесный" термин, который бы говорил о таких контрактах взаимодействия, которые работают поверх HTTP и соответствуют архитектуре REST. Поэтому и REST API/Web API , что переводится как "контракт, работающий поверх HTTP в соответствии с архитектурой Web".

1.4 Что такое веб-сервис (ссылка на ресурс W3C		https://www.w3.org/TR/ws-arch/#id2260892);     )
[Определение: Веб-сервис - это программная система, разработанная для поддержки совместимого межмашинного взаимодействия по сети. У нее есть интерфейс, описанный в машинно-обрабатываемом формате (в частности, WSDL). Другие системы взаимодействуют с веб-сервисом способом, предписанным его описанием, используя SOAP-сообщения, обычно передаваемые с использованием HTTP с сериализацией XML в сочетании с другими стандартами, связанными с Веб.] 


Веб-служба, веб-сервис (англ. web service) - идентифицируемая уникальным веб-адресом (URL-адресом) программная система со стандартизированными интерфейсами. Веб-службы могут взаимодействовать друг с другом и со сторонними приложениями посредством сообщений, основанных на определённых протоколах (SOAP, XML-RPC и т. д.) и соглашениях (REST). Веб-служба является единицей модульности при использовании сервис-ориентированной архитектуры приложения (SOA).
В обиходе веб-сервисами называют услуги, оказываемые в Интернете.
Например, электронная почта отправляет письма, поисковик Google ищет информацию в интернете, а сайт с погодой показывает прогноз.
веб-сервис - вспомогательный код. Для сбора метрик, например.

Отличие сервиса от сервера
Сервис (микросервис) - это программа, размещаемая на сервере, которая предоставляет определенную функцию, находясь по определенному адресу и используя четко определенные интерфейсы и логику. Сегодня это чаще всего интерфейсы API.
Сервер может хостить ( Размещать данные на сервере) в себе тысячи сервисов. Впрочем, и один сервис может быть размещен на нескольких серверах. В более широком плане - сервер - это виртуальная машина, которая хостит в себе Apache, IIS и много-много web-сервисов. Еще в более широком плане - это железяка, которая хостит в себе множество виртуалок.




Веб сайт
веб-сайты состоят из веб страниц обьединенных между собой в единый ресурс, имеют простую архитектуру, и несут справочный характер,
под сайтом понимают справочную: лендинг, портфолио, визитку. Пользователь ничего не делает, а только читает, что написано.





веб-приложение

веб-приложение - специальные интерактивные  приложения, выполняющие квкую либо бизнес-логику, которые позволяют пользователю манипулировать данными (вводить, получать)
Под веб-приложением имеют в виду нечто более сложное: интернет-магазин, онлайн-банк, электронные госуслуги, соц сети, обмен мгновенными сообщениями, конвертер валют, онлайн переводчик. Там есть взаимодействие с клиентом.











web-сервер приложений 

Как работает web-сервер приложений 
Сервер приложений расширяет возможности веб-сервера, поддерживая динамическую генерацию контента, логику приложений и интеграцию с различными ресурсами. Он предоставляет среду выполнения, в которой можно запускать код приложения и взаимодействовать с другими программными компонентами. Он использует бизнес-логику для более эффективного преобразования данных, чем веб-сервер.

взаимодействие клиента и Веб-сервера приложений:
1.браузер отправляет HTTP-запрос на получение информации (к веб-серверу либо прямо на веб-приложение)
2.Веб-сервер передает запрос на сервер приложений
3.Сервер приложений применяет бизнес-логику и взаимодействует с другими серверами и сторонними системами для выполнения запроса
4.Сервер приложений отображает новую HTML-страницу и возвращает ее в ответ веб-серверу
5.Веб-сервер возвращает ответ браузеру
6.Браузер отображает информацию 














30) vpn

VPN (англ. virtual private network — «виртуальная частная сеть») — обобщённое название технологий, позволяющих обеспечить одно или несколько сетевых соединений поверх чьей-либо другой сети

В чем состоит принцип работы VPN?
VPN-подключение перенаправляет пакеты данных от вашего компьютера к другому удаленному серверу, перед тем как отправить их третьим лицам в Интернете. Далее представлены основные принципы, лежащие в основе технологии VPN.

Протокол туннелирования
Виртуальная частная сеть в основном создает безопасный тоннель передачи данных между вашим локальным компьютером и другим VPN-сервером в местоположении, которое находится за тысячи километров. Когда вы выходите в Интернет, этот VPN-сервер становится источником всех ваших данных. Ваш интернет-провайдер и другие третьи лица больше не могут видеть содержимое вашего интернет-трафика. 

VPN защищает весь сетевой трафик, в то время как прокси работает на уровне приложения. Оба сервиса скрывают IP-адрес, но только VPN перенаправляет данные через зашифрованный туннель. Прокси подходит для просмотра контента в интернете, но он не так безопасен, как VPN. VPN дает большую защиту и имеет ряд преимуществ. 

















31) балансировщик сервер (load balancer)

Балансировщик нагрузки распределяет входящие запросы клиентов между группой серверов , в каждом случае возвращая ответ от выбранного сервера соответствующему клиенту. Балансировщики используются, когда объем запросов слишком велик для эффективного выполнения одним сервером

балансировщик может использоваться для баз данных и для серверов

несколько серверов (или БД) объединяются в кластер; нагрузка между ними распределяется при помощи комплекса специальных методов, называемых балансировкой. Помимо решения проблемы высоких нагрузок кластеризация помогает также обеспечить резервирование серверов друг на друга.
Эффективность кластеризации напрямую зависит от того, как распределяется (балансируется) нагрузка между элементами кластера.











32) как сделать так чтобы JS код на клиенте не смог прочитать cookie?

Параметр httponly
Флаг HttpOnly сообщит браузеру, что к этому файлу cookie может получить доступ только сервер. Основное преимущество этого заключается в том, что он предотвращает межсайтовый скриптинг (XSS). Например, это предотвратит запросы вредоносных файлов JavaScript, пытающихся украсть файлы cookie.Куки HTTPonly не доступны из JavaScript через свойства Document.cookie

Безопасное соединение (только через HTTPS)
Параметр secure гарантирует, что файлы cookie будут отправляться только через безопасное соединение SSL. Это предотвратит отправку файлов cookie через http: //, тем самым еще больше обезопасив файлы cookie.

use_only_cookies
параметр use_only_cookies сообщит вашему веб-сайту, что он должен хранить данные сеанса только в файле cookie, а не каким-либо другим способом. Это предотвращает атаки, связанные с передачей идентификаторов сеансов в URL-адресах.


document. оператор позволяющий вывести в реальном времени переменную
document.cookie 	JS команда, позволяет вывести в консоль cookie (в DevTools)










33) Что такое WADL?

Web Application Description Language — машинно-читаемое XML-описание для web-приложений HTTP. Аналог WSDL для SOAP. WADL моделирует ресурсы, предоставляемые сервисом, и взаимосвязи между ними.











34)  Что такое FTP?

FTP — протокол передачи файлов по сети, является одним из старейших прикладных протоколов. на сегодняшний день широко используется для распространения ПО и доступа к удалённым хостам












35) OWASP

Open Web Application Security Project — это открытый проект обеспечения безопасности веб-приложений. Сообщество OWASP включает в себя корпорации, образовательные организации и частных лиц со всего мира

OWASP Top 10 – это отчет или информационный документ, в котором перечислены основные проблемы, связанные с безопасностью веб-приложений. Он регулярно обновляется, чтобы постоянно отображать 10 наиболее серьезных рисков, с которыми сталкиваются организации. OWASP рекомендует всем компаниям учитывать выводы документа при построении корпоративных процессов, чтобы минимизировать и смягчить актуальные риски безопасности.
В последнем отчете OWASP перечислены 10 основных уязвимостей:

Инъекции (Injections).
Нарушенная аутентификация (Broken Authentication).
Раскрытие критически важных данных (Sensitive Data Exposure).
Внешние объекты XML (XXE) (XML External Entities (XXE)).
Нарушенный контроль доступа (Broken Access control).
Неправильная конфигурация безопасности (Security misconfigurations).
Межсайтовый скриптинг (XSS) (Cross Site Scripting (XSS)).
Небезопасная десериализация (Insecure Deserialization).
Использование компонентов с известными уязвимостями (Using Components with known vulnerabilities).
Недостаточно подробные журналы и слабый мониторинг (Insufficient logging and monitoring).









36) Что такое WebSocket и как проверить обрыв соединения?

WebSocket — протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером, используя постоянное соединение.

WebSocket разработан для воплощения в веб-браузерах и веб-серверах, но он может быть использован для любого клиентского или серверного приложения. Протокол WebSocket — это независимый протокол, основанный на протоколе TCP. Он делает возможным более тесное взаимодействие между браузером и веб-сайтом, способствуя распространению интерактивного содержимого и созданию приложений реального времени.

обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

Мы подключаем WS один раз, а затем сервер может отдавать нам ответы тогда, когда посчитает нужным

Как это работает?
Первое что мы делаем — отправляем обычный TCP-запрос на сервер, мы говорим, что хотим подключиться к серверу и ждём от него ответа. Такой процесс называется “рукопожатие” (Handshake), он используется повсеместно, например когда вы подключаетесь к роутеру ваш телефон отправляем запрос роутеру с ключами, роутер отвечает ОК и вы успешно подключаетесь.

Затем происходит обмен данными: допустим один из множества клиентов отправил HTTP-запрос серверу и нужно отдать ответ не только одному клиенту, а целой сети! Сервер в таком случае отдаст обычный ответ отправителю запроса, а всем другим пришлёт пакеты по WebSocket-соединению с полезными данными.

А как сервер узнает, что мы до сих пор подключены?😅
Ответ на данный вопрос достаточно легкий — сервер и клиент играют в пинг-понг😁🏓😳

Сервер периодически присылает ответ по WS с просьбой о действии - послать запрос на сервер. Если клиент отвечает до истечения тайм-аута — он подключен, если нет, то происходит разрыв соединения до следующего рукопожатия👋

Полезно знать, что все ответы от сервера по WS игнорируются клиентом и сервером, до того как случится рукопожатие🤝

Почему соединение называется двухсторонним (дуплексным), а ответы мы получаем только от сервера?
На самом деле мы не только получаем ответы от сервера, а ещё и можем в двухстороннем порядке отправлять через WS запросы!😳










37) ajax

AJAX - асинхронные запросы с помощью JavaScript (Asynchonous JavaScript and XML). AJAX преследует все те же цели, что и HTTP, только делает это уже асинхронно. Если ранее нужно было для каждого запроса прописывать свой URL и перезагружать страницу, то теперь можно просто использовать AJAX и он сам будет отправлять нужные URL серверу и получать данные.

Особенности AJAX
Все ещё обычный запрос, который не поддерживает соединение, после того, как отдает ответ на запрос.
Все ещё заранее оговариваем действие, которое клиент хочет сделать в заголовке (HTTP Headers) - GET, POST, PUT, DELETE
Мы отправляем заголовок что хотим сделать каждый раз, как обраемся к серверу
Теперь мы делаем это асинхронно благодаря JavaScript












38) Man-in-the-Middle

Атака «человек посередине» (Man-in-the-Middle) — это форма кибератаки, при которой для перехвата данных используются методы, позволяющие внедриться в существующее подключение или процесс связи. Злоумышленник может быть пассивным слушателем в вашем разговоре, незаметно крадущим какие-то сведения, или активным участником, изменяя содержание ваших сообщений или выдавая себя за человека или систему, с которыми вы, по вашему мнению, разговариваете.

Многофакторная аутентификация может быть эффективной защитой от кражи учетных данных.

1. Отравление ARP-кэша
Протокол разрешения адресов (ARP) — это низкоуровневый процесс, который преобразует адрес машины (MAC) в IP-адрес в локальной сети.
Злоумышленники вводят в эту систему ложную информацию, чтобы заставить ваш компьютер принимать компьютер злоумышленника за сетевой шлюз. Когда вы подключаетесь к сети, злоумышленник получает весь ваш сетевой трафик (вместо вашего реального сетевого шлюза) и передает его по своему реальному месту назначения. Вам кажется, что все нормально. Но в это время злоумышленник видит все данные, которые вы принимаете и передаете.

2.Отравление кэша DNS
Отравлением кэша DNS называется действие, когда злоумышленник дает вам поддельную запись DNS, которая ведет на другой сайт. Он может выглядеть как Google, но это не Google, и злоумышленник будет перехватывать любые данные, которые вы вводите на поддельном сайте, в том числе имя пользователя и пароль:

3.Подмена HTTPS
Аббревиатура HTTPS вселяет в пользователей уверенность в том, что их данные «защищены». Здесь буква S означает secure — безопасный. По крайней мере, злоумышленник хочет, чтобы вы так думали. Злоумышленники создают веб-сайты HTTPS, которые выглядят как сайты с действующими сертификатами аутентификации, но URL-адрес у них немного другой. Например, они регистрируют имя веб-сайта с кодировкой Юникод, в котором буква «а» выглядит как «а», но не является таковой. Продолжим на примере условного сайта example.com: здесь URL может выглядеть как www.exаmple.com, но буква «а» в слове example будет кириллической. Это действительный символ Юникод, выглядящий точно так же, как и английская «а», но имеющая другое Юникод-значение.

4. Перехват Wi-Fi
Злоумышленники прослушивают трафик в общедоступных или незащищенных сетях Wi-Fi или создают сети Wi-Fi с распространёнными именами. Их цель — обманом заставить людей подключиться, чтобы украсть их учетные данные, номера банковских карт или любую другую информацию, которую пользователи отправляют в этой сети.
Перехват сеанса

5. Перехват сеанса — это атака «человек посередине», при которой злоумышленник наблюдает за вами, чтобы войти на веб-страницу (например, учетную запись банка или электронной почты), а затем крадет ваш cookie-файл сеанса для входа в ту же учетную запись из своего браузера. Этот вид атаки мы демонстрируем на нашем семинаре по кибератакам Live Cyber Attack, о котором упоминали ранее.
Как только злоумышленник получит ваш cookie-файл активного сеанса, он сможет делать на этом веб-сайте то же самое, что и вы. Чак (наш парень из примера) мог перевести все ваши сбережения на оффшорный счет, купить кучу товаров с помощью сохраненной банковской карты или использовать перехваченный сеанс, чтобы проникнуть в сеть вашей компании и глубоко внедриться в корпоративную сеть.


























=======================================================================================


параллельные запросы (сколько их можно отправить на сервер?)

адаптивная и респонсивная верстка

XHR  (XML+HTTP+Request)

API GW ?? 
Stripe GW


















